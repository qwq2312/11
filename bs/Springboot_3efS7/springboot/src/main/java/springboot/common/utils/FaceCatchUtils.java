/** * @ClassName faceCatchUtils * @Description 人脸识别算法 * @Version 1.0 */package springboot.common.utils;import cn.hutool.core.util.NumberUtil;import cn.hutool.core.util.StrUtil;import org.springframework.stereotype.Component;import javax.imageio.ImageIO;import java.awt.*;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Paths;import java.util.List;import java.util.*;import java.util.stream.Collectors;import java.util.stream.IntStream;@Componentpublic class FaceCatchUtils {	/**	 * 可选值为：1,2,4,8,16,32	 * 当值为64时会抛出异常，此时需要实现64位转10进制	 * radix 64 greater than Character.MAX_RADIX	 */	public static int compareLevel = 4;	public static Boolean isSimilar(String pic1Path, String pic2Path) throws IOException {		pic1Path = StrUtil.sub(pic1Path, pic1Path.indexOf("upload"), pic1Path.length());		pic2Path = StrUtil.sub(pic2Path, pic2Path.indexOf("upload"), pic2Path.length());		final List<Double> origin = getPicArrayData(pic1Path);		final List<Double> after = getPicArrayData(pic2Path);		Double pearsonBydim = getPearsonBydim(origin, after);		return !(NumberUtil.compare(pearsonBydim, getCompareThreshold()) < 0);	}	public static Double getCompareThreshold() {		return 0.7;	}	public static List<Double> getPicArrayData(String path) throws IOException {		BufferedImage image = ImageIO.read(Files.newInputStream(Paths.get(path)));		//初始化集合		final List<Double> picFingerprint = new ArrayList<>(compareLevel * compareLevel * compareLevel);		IntStream.range(0, compareLevel * compareLevel * compareLevel).forEach(i -> {			picFingerprint.add(i, 0.0);		});		//遍历像素点		for (int i = 0; i < image.getWidth(); i++) {			for (int j = 0; j < image.getHeight(); j++) {				Color color = new Color(image.getRGB(i, j));				//对像素点进行计算				putIntoFingerprintList(picFingerprint, color.getRed(), color.getGreen(), color.getBlue());			}		}		return picFingerprint;	}	/**	 * 放入像素的三原色进行计算，得到List的位置	 *	 * @param picFingerprintList picFingerprintList	 * @param r                  r	 * @param g                  g	 * @param b                  b	 * @return	 */	public static List<Double> putIntoFingerprintList(List<Double> picFingerprintList, int r, int g, int b) {		//比如r g b是126, 153, 200 且 compareLevel为16进制，得到字符串：79c ,然后转10进制，这个数字就是List的位置		final Integer index = Integer.valueOf(getBlockLocation(r) + getBlockLocation(g) + getBlockLocation(b), compareLevel);		final Double origin = picFingerprintList.get(index);		picFingerprintList.set(index, origin + 1);		return picFingerprintList;	}	/**	 * w	 * 计算 当前原色应该分在哪个区块	 *	 * @param colorPoint colorPoint	 * @return	 */	public static String getBlockLocation(int colorPoint) {		Optional<String> first = IntStream.range(0, compareLevel)				//以10进制计算分在哪个区块				.filter(i -> {					int areaStart = (256 / compareLevel) * i;					int areaEnd = (256 / compareLevel) * (i + 1) - 1;					return colorPoint >= areaStart && colorPoint <= areaEnd;				})				//如果compareLevel大于10则转为对应的进制的字符串				.mapToObj(location -> compareLevel > 10 ? Integer.toString(location, compareLevel) : location + "")				.findFirst();		return first.get();	}	public static void putIntoFingerprintMap(Map<Integer, Integer> picFingerprintMap, int r, int g, int b) {		final Integer picFingerprint = Integer.valueOf(getBlockLocation(r) + getBlockLocation(g) + getBlockLocation(b), compareLevel);		Integer value = picFingerprintMap.containsKey(picFingerprint) ? picFingerprintMap.get(picFingerprint) + 1 : 1;		picFingerprintMap.put(picFingerprint, value);	}	public static List<Double> getPicArrayDataByMap(String path) throws IOException {		BufferedImage bimg = ImageIO.read(new File(path));		final Map<Integer, Integer> picFingerprintMap = new HashMap<>();		for (int i = 0; i < bimg.getWidth(); i++) {			for (int j = 0; j < bimg.getHeight(); j++) {				//输出一列数据比对				Color color = new Color(bimg.getRGB(i, j));				int r = color.getRed();				int g = color.getGreen();				int b = color.getBlue();				putIntoFingerprintMap(picFingerprintMap, r, g, b);			}		}		final List<Integer> keys = picFingerprintMap.keySet().stream().sorted().collect(Collectors.toList());		final ArrayList<Double> picFingerprintList = new ArrayList<>(keys.size());		keys.forEach(key -> {			picFingerprintList.add(Double.valueOf(picFingerprintMap.get(key)));		});		return picFingerprintList;	}	public static Double getPearsonBydim(List<Double> ratingOne, List<Double> ratingTwo) {		try {			if (ratingOne.size() != ratingTwo.size()) {//两个变量的观测值是成对的，每对观测值之间相互独立。				if (ratingOne.size() > ratingTwo.size()) {//保留小的处理大					List<Double> temp = ratingOne;					ratingOne = new ArrayList<>();					for (int i = 0; i < ratingTwo.size(); i++) {						ratingOne.add(temp.get(i));					}				} else {					List<Double> temp = ratingTwo;					ratingTwo = new ArrayList<>();					for (int i = 0; i < ratingOne.size(); i++) {						ratingTwo.add(temp.get(i));					}				}			}			double sim = 0D;//最后的皮尔逊相关度系数			double commonItemsLen = ratingOne.size();//操作数的个数			double oneSum = 0D;//第一个相关数的和			double twoSum = 0D;//第二个相关数的和			double oneSqSum = 0D;//第一个相关数的平方和			double twoSqSum = 0D;//第二个相关数的平方和			double oneTwoSum = 0D;//两个相关数的乘积和			for (int i = 0; i < ratingOne.size(); i++) {//计算				double oneTemp = ratingOne.get(i);				double twoTemp = ratingTwo.get(i);				//求和				oneSum += oneTemp;				twoSum += twoTemp;				oneSqSum += Math.pow(oneTemp, 2);				twoSqSum += Math.pow(twoTemp, 2);				oneTwoSum += oneTemp * twoTemp;			}			double num = (commonItemsLen * oneTwoSum) - (oneSum * twoSum);			double den = Math.sqrt((commonItemsLen * oneSqSum - Math.pow(oneSum, 2)) * (commonItemsLen * twoSqSum - Math.pow(twoSum, 2)));			sim = (den == 0) ? 1 : num / den;			return sim;		} catch (Exception e) {			return null;		}	}	public static double getPearsonCorrelationScore(List<Double> x, List<Double> y) {		if (x.size() != y.size())			throw new RuntimeException("数据不正确！");		double[] xData = new double[x.size()];		double[] yData = new double[x.size()];		for (int i = 0; i < x.size(); i++) {			xData[i] = x.get(i);			yData[i] = y.get(i);		}		return getPearsonCorrelationScore(xData, yData);	}	public static double getPearsonCorrelationScore(double[] xData, double[] yData) {		if (xData.length != yData.length)			throw new RuntimeException("数据不正确！");		double xMeans;		double yMeans;		double numerator = 0;// 求解皮尔逊的分子		double denominator = 0;// 求解皮尔逊系数的分母		double result = 0;		// 拿到两个数据的平均值		xMeans = getMeans(xData);		yMeans = getMeans(yData);		// 计算皮尔逊系数的分子		numerator = generateNumerator(xData, xMeans, yData, yMeans);		// 计算皮尔逊系数的分母		denominator = generateDenomiator(xData, xMeans, yData, yMeans);		// 计算皮尔逊系数		result = numerator / denominator;		return result;	}	/**	 * 计算分子	 *	 * @param xData	 * @param xMeans	 * @param yData	 * @param yMeans	 * @return	 */	private static double generateNumerator(double[] xData, double xMeans, double[] yData, double yMeans) {		double numerator = 0.0;		for (int i = 0; i < xData.length; i++) {			numerator += (xData[i] - xMeans) * (yData[i] - yMeans);		}		return numerator;	}	/**	 * 生成分母	 *	 * @param yMeans	 * @param yData	 * @param xMeans	 * @param xData	 * @return 分母	 */	private static double generateDenomiator(double[] xData, double xMeans, double[] yData, double yMeans) {		double xSum = 0.0;		for (int i = 0; i < xData.length; i++) {			xSum += (xData[i] - xMeans) * (xData[i] - xMeans);		}		double ySum = 0.0;		for (int i = 0; i < yData.length; i++) {			ySum += (yData[i] - yMeans) * (yData[i] - yMeans);		}		return Math.sqrt(xSum) * Math.sqrt(ySum);	}	/**	 * 根据给定的数据集进行平均值计算	 *	 * @param	 * @return 给定数据集的平均值	 */	private static double getMeans(double[] datas) {		double sum = 0.0;		for (int i = 0; i < datas.length; i++) {			sum += datas[i];		}		return sum / datas.length;	}}